# 挑战程序设计竞赛 1.6.1 三角形 计算组合三角形的最大周长

标签（空格分隔）： 挑战程序设计竞赛 算法竞赛

---

题目很简单，就是输入一个数n，表示接下来输入一个有n个元素的数列，作为一些帮的长度，然后挑选其中的棒组成周长最长的三角形，输出这个最大周长。

    input
    
    5
    2 3 4 5 10

    output
    
    12

很简单的一道小题，但是用的方法很多样。书上给了全部遍历的方法，计算每一个可行组合的长度，输出最大值。但是计算复杂度太大了，是o(n^3)。这里还有一种办法。

考虑这个问题，可否排序后做。如果排序后最大的三个元素之和满足条件（两边之和大于第三边），那这一个肯定就是最佳答案；反之，如果排序后最大的三个元素之和不满足条件，那以这三个元素中的最大元素为最长边的组合肯定也不能满足条件了，因为另外两个边亦是剩下的所有边中最大的，如果它们的和都不大于最长边，那其余边的和肯定也不大于了。此时，就可以以下一个元素作为最长边，继续该算法过程。
实现起来也很容易，就是得用qsort等排序函数。

```C++
#include <iostream>
#include <algorithm>
#include <cstdlib>
#define N 1005
using namespace std;
int a[N];
int cmp(const void *a,const void *b)	{return -*(int*)a+*(int*)b;}
int main()	{
	int n,i=0,n0,ans=0;
	scanf("%d",&n);n0=n;
	while (n0--)	scanf("%d",&a[i++]);
	qsort(a,n,sizeof(int),cmp);
	for (int j=0;j<n;j++)	{
		if (a[j]<a[j+1]+a[j+2])	{
			ans=a[j]+a[j+1]+a[j+2];
			break;
		}
	}
	printf("%d\n",ans);
	return 0;
} 
```
我们按快排算法的平均复杂度o(nlogn)作为指标（虽然经常比这个要快），那么上述算法的时间复杂度大致为o(nlogn)+o(n)=o(nlogn),显然比原先的o(n^3)要快得多。这也是书上提示，但是未说明的那种复杂度o(nlogn)的算法。如果把快排换成归并排序，也可以。









